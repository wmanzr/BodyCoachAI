<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BodyCoach AI</title>
    <link rel="stylesheet" th:href="@{/css/index.css}">
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="brand">
                <h1>BodyCoach AI</h1>
                <p>Персональный тренер и питание • RAG • InBody</p>
            </div>
            <div class="rag-toggle">
                <label class="toggle-switch">
                    <input type="checkbox" id="ragToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
                <span class="rag-label" id="ragLabel">RAG</span>
            </div>
        </div>
        
        <!-- Экран инициализации -->
        <div id="initScreen" class="init-screen">
            <div class="init-content">
                <h2>BodyCoach AI</h2>
                <p>Нажмите «Начать», чтобы получить токены и активировать интерфейс.</p>
                <button id="initButton" class="btn btn-primary init-button">Начать</button>
                <div id="initStatus" class="init-status"></div>
            </div>
        </div>
        
        <!-- Чат (скрыт до инициализации) -->
        <div class="chat-container" id="chatContainer" style="display: none;">
            <div class="message assistant">
                <div class="message-bubble">
                    <div style="font-weight: 600; margin-bottom: 8px;">Привет! Я BodyCoach AI.</div>
                    <div style="color: rgba(231,241,238,0.82);">
                        Я умею анализировать отчёты InBody по фото, составлять планы тренировок и питания,
                        а также отвечать на вопросы по теме спорта и здоровья.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Поле ввода -->
        <div class="input-container">
            <div class="image-preview" id="imagePreview"></div>
            <div class="input-wrapper">
                <div class="file-input-wrapper">
                    <input type="file" id="imageInput" accept="image/*">
                    <label for="imageInput" class="btn" title="Загрузить фото">
                        <svg class="btn-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                            <path d="M7 7l2-2h6l2 2h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h2z" stroke="currentColor" stroke-width="1.8" />
                            <path d="M12 18a4 4 0 1 0 0-8 4 4 0 0 0 0 8z" stroke="currentColor" stroke-width="1.8" />
                        </svg>
                        Фото
                    </label>
                </div>
                <button id="recordButton" class="btn btn-danger" title="Голосовой ввод">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                        <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3z" stroke="currentColor" stroke-width="1.8"/>
                        <path d="M19 11a7 7 0 0 1-14 0" stroke="currentColor" stroke-width="1.8"/>
                        <path d="M12 18v3" stroke="currentColor" stroke-width="1.8"/>
                        <path d="M8 21h8" stroke="currentColor" stroke-width="1.8"/>
                    </svg>
                    Голос
                </button>
                <textarea id="messageInput" placeholder="Введите сообщение или загрузите фото отчёта InBody..." rows="1"></textarea>
                <button id="sendButton" class="btn btn-primary">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                        <path d="M4 12l16-8-6 16-3-7-7-1z" stroke="currentColor" stroke-width="1.8" stroke-linejoin="round"/>
                    </svg>
                    Отправить
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // Элементы DOM
        const elements = {
            chatContainer: document.getElementById('chatContainer'),
            initScreen: document.getElementById('initScreen'),
            initButton: document.getElementById('initButton'),
            initStatus: document.getElementById('initStatus'),
            messageInput: document.getElementById('messageInput'),
            imageInput: document.getElementById('imageInput'),
            imagePreview: document.getElementById('imagePreview'),
            sendButton: document.getElementById('sendButton'),
            recordButton: document.getElementById('recordButton'),
            ragToggle: document.getElementById('ragToggle'),
            ragLabel: document.getElementById('ragLabel')
        };
        
        // Состояние приложения
        const state = {
            selectedImages: [],
            systemInitialized: false,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            ragEnabled: true
        };

        function setInputsEnabled(enabled) {
            elements.messageInput.disabled = !enabled;
            elements.imageInput.disabled = !enabled;
            elements.sendButton.disabled = !enabled;
            elements.recordButton.disabled = !enabled;
        }

        // До "Начать" всё снизу недоступно
        setInputsEnabled(false);
        
        // Загружает актуальный статус RAG с бэкенда при загрузке страницы
        async function loadRagStatus() {
            try {
                const response = await fetch('/api/rag/status');
                const data = await response.json();
                state.ragEnabled = data.ragEnabled;
                elements.ragToggle.checked = state.ragEnabled;
                updateRagVisualState();
            } catch (error) {
                console.error('Ошибка загрузки статуса RAG:', error);
            }
        }
        
        // Обновляет визуальное состояние интерфейса в зависимости от статуса RAG
        function updateRagVisualState() {
            if (state.ragEnabled) {
                document.body.classList.remove('rag-disabled');
                elements.ragLabel.textContent = 'RAG';
            } else {
                document.body.classList.add('rag-disabled');
                elements.ragLabel.textContent = 'RAG';
            }
        }
        
        // Отправляет на бэкенд запрос на переключение состояния RAG
        async function toggleRag() {
            try {
                const response = await fetch('/api/rag/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                state.ragEnabled = data.ragEnabled;
                updateRagVisualState();
            } catch (error) {
                console.error('Ошибка переключения RAG:', error);
                // Откатываем состояние toggle если запрос не удался
                elements.ragToggle.checked = state.ragEnabled;
            }
        }
        
        // Обработчик переключения RAG
        elements.ragToggle.addEventListener('change', toggleRag);
        
        // Загружаем статус RAG при загрузке страницы
        loadRagStatus();
        
        // Вызывает /api/init и при успешном ответе включает интерфейс чата
        async function initializeSystem() {
            elements.initButton.disabled = true;
            elements.initStatus.textContent = 'Инициализация системы...';
            elements.initStatus.className = 'init-status';
            
            try {
                const response = await fetch('/api/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    elements.initStatus.textContent = '✓ Система успешно инициализирована!';
                    elements.initStatus.className = 'init-status success';
                    
                    setTimeout(() => {
                        elements.initScreen.style.display = 'none';
                        elements.chatContainer.style.display = 'flex';
                        state.systemInitialized = true;
                        setInputsEnabled(true);
                    }, 1000);
                } else {
                    showError('✗ Ошибка: ' + data.message);
                }
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                showError('✗ Ошибка при инициализации. Проверьте настройки .env файла.');
            }
        }
        
        // Показывает текст ошибки и разблокирует кнопку инициализации
        function showError(message) {
            elements.initStatus.textContent = message;
            elements.initStatus.className = 'init-status error';
            elements.initButton.disabled = false;
        }
        
        // Обработчик выбора файла: читает выбранное изображение и показывает превью (1 фото)
        elements.imageInput.addEventListener('change', function(e) {
            const file = e.target.files && e.target.files[0];
            state.selectedImages = [];
            elements.imagePreview.innerHTML = '';
            
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;
                state.selectedImages = [imageData];
                
                const img = document.createElement('img');
                img.src = imageData;
                img.onclick = () => removeImage(imageData);
                elements.imagePreview.appendChild(img);
            };
            reader.readAsDataURL(file);
        });
        
        // Удаляет выбранное изображение из состояния и из превью
        function removeImage(imageData) {
            state.selectedImages = state.selectedImages.filter(img => img !== imageData);
            updateImagePreview();
        }
        
        // Перерисовывает блок превью изображений на основе текущего state.selectedImages
        function updateImagePreview() {
            elements.imagePreview.innerHTML = '';
            state.selectedImages.forEach(imageData => {
                const img = document.createElement('img');
                img.src = imageData;
                img.onclick = () => removeImage(imageData);
                elements.imagePreview.appendChild(img);
            });
        }
        
        // Отправка сообщения по Enter
        elements.messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Автоматическое изменение размера textarea
        elements.messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 150) + 'px';
        });
        
        // Собирает текст и (опционально) картинку и отправляет запрос в /api/chat
        async function sendMessage() {
            if (!state.systemInitialized) {
                alert('Пожалуйста, сначала инициализируйте систему, нажав кнопку "Начать"');
                return;
            }
            
            const text = elements.messageInput.value.trim();
            const images = state.selectedImages;
            const image = images && images.length > 0 ? images[0] : null;
            
            if (!text && images.length === 0) {
                return;
            }
            
            // Добавляем сообщение пользователя в чат
            addMessage('user', text, images);
            
            // Очищаем поля
            clearInput();
            
            // Блокируем кнопку отправки
            setLoading(true);
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        image: image
                    })
                });
                
                const data = await response.json();
                
                // Добавляем ответ ассистента в чат
                addMessage('assistant', data.response, null, data.agent, data.type, data.data);
                
            } catch (error) {
                console.error('Ошибка:', error);
                addMessage('assistant', 'Произошла ошибка при обработке запроса. Попробуйте еще раз.');
            } finally {
                setLoading(false);
            }
        }
        
        // Очищает текстовое поле, инпут для файлов и предпросмотр изображений
        function clearInput() {
            elements.messageInput.value = '';
            elements.imageInput.value = '';
            state.selectedImages = [];
            elements.imagePreview.innerHTML = '';
        }
        
        // Переключает кнопку отправки в состояние загрузки и обратно
        function setLoading(loading) {
            elements.sendButton.disabled = loading;
            elements.sendButton.innerHTML = loading
                ? '<span class="loading"></span>'
                : '<svg class="btn-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 12l16-8-6 16-3-7-7-1z" stroke="currentColor" stroke-width="1.8" stroke-linejoin="round"/></svg>Отправить';
        }
        
        // Создаёт DOM-элементы сообщения (пользователь или ассистент) и добавляет их в чат
        function addMessage(type, text, images, agent, responseType, data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            
            // Изображения
            if (images && images.length > 0) {
                images.forEach(imgSrc => {
                    const img = document.createElement('img');
                    img.src = imgSrc;
                    img.style.cssText = 'width: 200px; height: 200px; object-fit: cover; border-radius: 10px; margin-bottom: 10px;';
                    bubble.appendChild(img);
                });
            }
            
            // Структурированные данные
            if (data) {
                if (data.fileName) {
                    const excelDiv = document.createElement('div');
                    excelDiv.innerHTML = '<b>Excel-таблица готова.</b><br>' +
                        '<a class="btn btn-primary download-btn" href="/api/files/' + data.fileName + '">' +
                        '<svg class="btn-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">' +
                        '<path d="M12 3v10m0 0l4-4m-4 4l-4-4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>' +
                        '<path d="M5 21h14" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>' +
                        '</svg>' +
                        'Скачать файл' +
                        '</a>';
                    bubble.appendChild(excelDiv);
                    // Не показываем текст если есть fileName
                    text = null;
                }
                if (data.table) {
                    const tableDiv = document.createElement('div');
                    tableDiv.innerHTML = '<pre>' + data.table + '</pre>';
                    bubble.appendChild(tableDiv);
                }
                if (data.plan) {
                    const planDiv = document.createElement('div');
                    planDiv.style.cssText = 'margin-top: 15px; padding: 15px; background: #f0f0f0; border-radius: 10px;';
                    planDiv.innerHTML = data.plan.replace(/\n/g, '<br>');
                    bubble.appendChild(planDiv);
                }
            }
            
            // Текст
            if (text) {
                const textDiv = document.createElement('div');
                textDiv.innerHTML = text.replace(/\n/g, '<br>');
                bubble.appendChild(textDiv);
            }
            
            messageDiv.appendChild(bubble);
            
            // Бейдж агента
            if (agent) {
                const badge = document.createElement('div');
                badge.className = 'agent-badge';
                badge.textContent = agent;
                messageDiv.appendChild(badge);
            }
            
            elements.chatContainer.appendChild(messageDiv);
            elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight;
        }
        
        // Голосовой ввод
        elements.recordButton.addEventListener('click', toggleRecording);
        
        // Переключает состояние голосовой записи: старт/стоп
        async function toggleRecording() {
            if (!state.isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        }
        
        // Запрашивает доступ к микрофону и начинает запись аудио через MediaRecorder
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                
                state.mediaRecorder.ondataavailable = (event) => {
                    state.audioChunks.push(event.data);
                };
                
                state.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });
                    
                    try {
                        const pcmBlob = await convertToPcm16kMono(audioBlob);
                        await sendAudioToServer(pcmBlob, 'recording.pcm');
                    } catch (e) {
                        alert('Ошибка: не удалось конвертировать аудио для распознавания. Откройте консоль (F12) и пришлите лог.');
                    }
                    stream.getTracks().forEach(track => track.stop());
                };
                
                // timeslice помогает получить chunks во время записи
                state.mediaRecorder.start(250);
                state.isRecording = true;
                elements.recordButton.classList.add('recording');
                elements.recordButton.disabled = false;
            } catch (error) {
                console.error('Ошибка доступа к микрофону:', error);
                alert('Не удалось получить доступ к микрофону');
            }
        }
        
        // Останавливает запись аудио и сбрасывает визуальное состояние кнопки записи
        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
                state.isRecording = false;
                elements.recordButton.classList.remove('recording');
            }
        }
        
        // Отправляет записанное аудио на /api/speech и подставляет распознанный текст в поле ввода
        async function sendAudioToServer(audioBlob, filename = 'recording.pcm') {
            const formData = new FormData();
            formData.append('audio', audioBlob, filename);
            
            try {
                const response = await fetch('/api/speech', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                if (data.status === 'success') {
                    const text = (data.text ?? '').toString();
                    elements.messageInput.value = text;
                } else if (data.status === 'error') {
                    console.error('STT error:', data.message);
                }
            } catch (error) {
                console.error('Ошибка отправки аудио:', error);
            }
        }

        // Конвертирует audio/webm (opus) в Blob с PCM16 mono 16kHz для сервера
        async function convertToPcm16kMono(audioBlob) {
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));

            // ресемпл в 16kHz
            const targetRate = 16000;
            const offline = new OfflineAudioContext(1, Math.ceil(decoded.duration * targetRate), targetRate);
            const source = offline.createBufferSource();
            source.buffer = decoded;
            source.connect(offline.destination);
            source.start(0);
            const rendered = await offline.startRendering();

            const samples = rendered.getChannelData(0);
            const pcmBuffer = new ArrayBuffer(samples.length * 2);
            const view = new DataView(pcmBuffer);
            for (let i = 0; i < samples.length; i++) {
                let s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }

            return new Blob([pcmBuffer], { type: 'application/octet-stream' });
        }
        
        // Инициализация обработчиков событий
        elements.initButton.addEventListener('click', initializeSystem);
        elements.sendButton.addEventListener('click', sendMessage);
    </script>
</body>
</html>
